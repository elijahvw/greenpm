{"ast":null,"code":"import { propertyService } from './propertyService';\nimport { leaseService } from './leaseService';\nclass PropertyLeaseService {\n  /**\n   * Get all properties with their current lease information\n   */\n  async getPropertiesWithLeaseInfo() {\n    try {\n      // Fetch both properties and leases\n      const [properties, leases] = await Promise.all([propertyService.getProperties(), leaseService.getLeases()]);\n\n      // Create a map of property ID to current lease\n      const propertyLeaseMap = new Map();\n      leases.forEach(lease => {\n        const propertyId = lease.propertyId || lease.property_id;\n        if (propertyId && (lease.status === 'active' || lease.status === 'pending')) {\n          // Only keep the most recent active/pending lease per property\n          const existing = propertyLeaseMap.get(propertyId);\n          if (!existing || new Date(lease.createdAt || lease.created_at || '') > new Date(existing.createdAt || existing.created_at || '')) {\n            propertyLeaseMap.set(propertyId, lease);\n          }\n        }\n      });\n\n      // Combine properties with lease information\n      const propertiesWithLeaseInfo = properties.map(property => {\n        const currentLease = propertyLeaseMap.get(property.id);\n        let lease_status = 'vacant';\n        let current_lease = undefined;\n        if (currentLease) {\n          lease_status = currentLease.status === 'active' ? 'occupied' : 'pending';\n          current_lease = {\n            id: currentLease.id,\n            status: currentLease.status || '',\n            start_date: currentLease.startDate || currentLease.start_date,\n            end_date: currentLease.endDate || currentLease.end_date,\n            monthly_rent: currentLease.monthlyRent || currentLease.rent_amount || currentLease.monthly_rent,\n            tenant_name: currentLease.tenant_name || currentLease.tenantName,\n            tenant_email: currentLease.tenant_email || currentLease.tenantEmail\n          };\n        }\n        return {\n          ...property,\n          lease_status,\n          current_lease\n        };\n      });\n      return propertiesWithLeaseInfo;\n    } catch (error) {\n      console.error('Error fetching properties with lease info:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get lease history for a specific property\n   */\n  async getPropertyLeaseHistory(propertyId) {\n    try {\n      const allLeases = await leaseService.getLeases();\n      return allLeases.filter(lease => (lease.propertyId || lease.property_id) === propertyId).sort((a, b) => {\n        const dateA = new Date(a.createdAt || a.created_at || '');\n        const dateB = new Date(b.createdAt || b.created_at || '');\n        return dateB.getTime() - dateA.getTime(); // Most recent first\n      });\n    } catch (error) {\n      console.error('Error fetching property lease history:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get properties filtered by lease status\n   */\n  async getPropertiesByLeaseStatus(status) {\n    try {\n      const propertiesWithLeaseInfo = await this.getPropertiesWithLeaseInfo();\n      return propertiesWithLeaseInfo.filter(property => property.lease_status === status);\n    } catch (error) {\n      console.error('Error fetching properties by lease status:', error);\n      throw error;\n    }\n  }\n}\nexport const propertyLeaseService = new PropertyLeaseService();","map":{"version":3,"names":["propertyService","leaseService","PropertyLeaseService","getPropertiesWithLeaseInfo","properties","leases","Promise","all","getProperties","getLeases","propertyLeaseMap","Map","forEach","lease","propertyId","property_id","status","existing","get","Date","createdAt","created_at","set","propertiesWithLeaseInfo","map","property","currentLease","id","lease_status","current_lease","undefined","start_date","startDate","end_date","endDate","monthly_rent","monthlyRent","rent_amount","tenant_name","tenantName","tenant_email","tenantEmail","error","console","getPropertyLeaseHistory","allLeases","filter","sort","a","b","dateA","dateB","getTime","getPropertiesByLeaseStatus","propertyLeaseService"],"sources":["/Users/elijahward/Documents/greenpm/frontend/src/services/propertyLeaseService.ts"],"sourcesContent":["import { Property } from '../types/property';\nimport { Lease } from '../types/lease';\nimport { propertyService } from './propertyService';\nimport { leaseService } from './leaseService';\n\nexport interface PropertyWithLeaseInfo extends Property {\n  lease_status: 'vacant' | 'occupied' | 'pending';\n  current_lease?: {\n    id: string;\n    status: string;\n    start_date?: string;\n    end_date?: string;\n    monthly_rent?: number;\n    tenant_name?: string;\n    tenant_email?: string;\n  };\n}\n\nclass PropertyLeaseService {\n  /**\n   * Get all properties with their current lease information\n   */\n  async getPropertiesWithLeaseInfo(): Promise<PropertyWithLeaseInfo[]> {\n    try {\n      // Fetch both properties and leases\n      const [properties, leases] = await Promise.all([\n        propertyService.getProperties(),\n        leaseService.getLeases()\n      ]);\n\n      // Create a map of property ID to current lease\n      const propertyLeaseMap = new Map<string, Lease>();\n      \n      leases.forEach(lease => {\n        const propertyId = lease.propertyId || lease.property_id;\n        if (propertyId && (lease.status === 'active' || lease.status === 'pending')) {\n          // Only keep the most recent active/pending lease per property\n          const existing = propertyLeaseMap.get(propertyId);\n          if (!existing || new Date(lease.createdAt || lease.created_at || '') > new Date(existing.createdAt || existing.created_at || '')) {\n            propertyLeaseMap.set(propertyId, lease);\n          }\n        }\n      });\n\n      // Combine properties with lease information\n      const propertiesWithLeaseInfo: PropertyWithLeaseInfo[] = properties.map(property => {\n        const currentLease = propertyLeaseMap.get(property.id);\n        \n        let lease_status: 'vacant' | 'occupied' | 'pending' = 'vacant';\n        let current_lease = undefined;\n\n        if (currentLease) {\n          lease_status = currentLease.status === 'active' ? 'occupied' : 'pending';\n          current_lease = {\n            id: currentLease.id,\n            status: currentLease.status || '',\n            start_date: currentLease.startDate || currentLease.start_date,\n            end_date: currentLease.endDate || currentLease.end_date,\n            monthly_rent: currentLease.monthlyRent || currentLease.rent_amount || currentLease.monthly_rent,\n            tenant_name: currentLease.tenant_name || currentLease.tenantName,\n            tenant_email: currentLease.tenant_email || currentLease.tenantEmail\n          };\n        }\n\n        return {\n          ...property,\n          lease_status,\n          current_lease\n        };\n      });\n\n      return propertiesWithLeaseInfo;\n    } catch (error) {\n      console.error('Error fetching properties with lease info:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get lease history for a specific property\n   */\n  async getPropertyLeaseHistory(propertyId: string): Promise<Lease[]> {\n    try {\n      const allLeases = await leaseService.getLeases();\n      return allLeases.filter(lease => \n        (lease.propertyId || lease.property_id) === propertyId\n      ).sort((a, b) => {\n        const dateA = new Date(a.createdAt || a.created_at || '');\n        const dateB = new Date(b.createdAt || b.created_at || '');\n        return dateB.getTime() - dateA.getTime(); // Most recent first\n      });\n    } catch (error) {\n      console.error('Error fetching property lease history:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get properties filtered by lease status\n   */\n  async getPropertiesByLeaseStatus(status: 'vacant' | 'occupied' | 'pending'): Promise<PropertyWithLeaseInfo[]> {\n    try {\n      const propertiesWithLeaseInfo = await this.getPropertiesWithLeaseInfo();\n      return propertiesWithLeaseInfo.filter(property => property.lease_status === status);\n    } catch (error) {\n      console.error('Error fetching properties by lease status:', error);\n      throw error;\n    }\n  }\n}\n\nexport const propertyLeaseService = new PropertyLeaseService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}